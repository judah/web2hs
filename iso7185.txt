This is taken from 
http://pascal-central.com/iso7185.html#6.7 Expressions
which is a web copy (partially OCR'd) of the grammar used by ISO7185.


actual-parameter = expression | variable-access | procedure-identifier
                 | function-identifier.
actual-parameter-list = '(' actual-parameter { ',' actual-parameter } ')' .
adding-operator = '+' | '-' | 'or' .
apostrophe-image = '"' .
array-type = 'array' '[' index-type { ',' index-type } ']' 'of' component-type .
array-variable = variable-access .
assignment-statement = ( variable-access | function-identifier ) ':=' expression .
base-type = ordinal-type .
block = label-declaration-part constant-definition-part type-definition-part
        variable-declaration-part procedure-and-function-declaration-part
        statement-part .
Boolean-expression = expression .
bound-identifier = identifier .
buffer-variable = file-variable '"' .
case-constant = constant .
case-constant-list = case-constant { ',' case-constant } .
case-index = expression .
case-list-element = case-constant-list ':' statement .
case-statement = 'case' case-index 'of' case-list-element
                 { ';' case-list-element } [ ';' ] 'end' .
character-string = ''' string-element { string-element } '''
component-type = type-denoter .
component-variable = indexed-variable | field-designator.
compound-statement = 'begin' statement-sequence 'end'.
conditional-statement = if-statement | case-statement.
conformant-array-parameter-specification = value-conformant-array-specification
                                         | variable-conformant-array-specification.
 
conformant-array-schema = packed-conformant-array-schema
                        | unpacked-conformant-array-schema.
 
constant = [ sign ] ( unsigned-number | constant-identifier )
         | character-string.
constant-definition = identifier '=' constant.
constant-definition-part = [ 'const' constant-definition ';' { constant-definition ';' } ] .
constant-identifier = identifier .
control-variable = entire-variable .
digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
digit-sequence = digit { digit } .
directive = letter { letter | digit }.
domain-type = type-identifier.
else-part = 'else' statement.
empty-statement =.
entire-variable = variable-identifier.
enumerated-type = '(' identifier-list ')'.
expression = simple-expression [ relational-operator simple-expression ].
factor > bound-identifier.
factor > variable-access | unsigned-constant | function-designator
       | set-constructor | '(' expression ')' | 'not' factor.
field-designator = record-variable '.' field-specifier | field-designator-identifier.
field-designator-identifier = identifier.
field-identifier = identifier.
field-list = [ ( fixed-part [ ';' variant-part ] | variant-part ) [ ';' ] ].
field-specifier = field-identifier.
file-type = 'file' 'of' component-type.
file-variable = variable-access.
final-value = expression.
fixed-part = record-section f ';' record-section g.
for-statement = 'for' control-variable ':=' initial-value ( 'to' | 'downto' ) final-value
                'do' statement.
formal-parameter-list = '(' formal-parameter-section f ';' formal-parameter-section } ')' .
formal-parameter-section > value-parameter-specification
                         | variable-parameter-specification
                         | procedural-parameter-specification
                         | functional-parameter-specification.
formal-parameter-section > conformant-array-parameter-specification.
fractional-part = digit-sequence.
function-block = block.
function-declaration = function-heading ';'directive
                     | function-identification ';' function-block
                     | function-heading ';' function-block.
function-designator = function-identifier [ actual-parameter-list ].
function-heading = 'function' identifier [ formal-parameter-list ] ':' result-type.
function-identification = 'function' function-identifier.
function-identifier = identifier.
functional-parameter-specification = function-heading.
goto-statement = 'goto' label.
identified-variable = pointer-variable '"'.
identifier = letter f letter | digit g.
identifier-list = identifier f ',' identifier g.
if-statement = 'if' Boolean-expression 'then' statement [ else-part ].
index-expression = expression.
index-type = ordinal-type.
index-type-specification = identifier '..' identifier ':' ordinal-type-identifier.
indexed-variable = array-variable '[' index-expression, f ',' index-expression
initial-value = expression.
label = digit-sequence.
label-declaration-part = [ 'label' label { ',' label } ';' ] .
letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
       | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
       | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'.
member-designator = expression [ '..' expression ].
multiplying-operator = '*' | '/' | 'div' | 'mod' | 'and'.
new-ordinal-type = enumerated-type | subrange-type.
new-pointer-type = '"' domain-type.
new-structured-type = [ 'packed' ] unpacked-structured-type.
new-type = new-ordinal-type | new-structured-type | new-pointer-type.
ordinal-type = new-ordinal-type | ordinal-type-identifier.
ordinal-type-identifier = type-identifier.
packed-conformant-array-schema = 'packed' 'array' '[' index-type-specification ']'
                                 'of' type-identifier.
pointer-type = new-pointer-type | pointer-type-identifier.
pointer-type-identifier = type-identifier.
pointer-variable = variable-access.
procedural-parameter-specification = procedure-heading.
procedure-and-function-declaration-part = { ( procedure-declaration
                                            | function-declaration ) ';' } .
procedure-block = block.
procedure-declaration = procedure-heading ';' directive
                      | procedure-identification ';' procedure-block
                      | procedure-heading ';' procedure-block .
procedure-heading = 'procedure' identifier [ formal-parameter-list ].
procedure-identification = 'procedure' procedure-identifier.
procedure-identifier = identifier.
procedure-statement = procedure-identifier ( [ actual-parameter-list ]
                      | read-parameter-list | readln-parameter-list
                      | write-parameter-list | writeln-parameter-list ) .
program = program-heading ';' program-block '.'.
program-block = block.
program-heading = 'program' identifier [ '(' program-parameter-list ')' ] .
program-parameter-list = identifier-list.
read-parameter-list = '(' [ file-variable ',' ] variable-access f ',' variable-access ')'
readln-parameter-list = [ '(' ( file-variable | variable-access )
                        { ',' variable-access } ')' ].
real-type-identifier = type-identifier.
record-section = identifier-list ':' type-denoter.
record-type = 'record' field-list 'end'.
record-variable = variable-access.
record-variable-list = record-variable f ',' record-variable g.
relational-operator = '=' | '<>' | '<' | '>' | '<=' | '>=' | 'in'.
repeat-statement = 'repeat' statement-sequence 'until' Boolean-expression.
repetitive-statement = repeat-statement | while-statement | for-statement.
result-type = simple-type-identifier | pointer-type-identifier.
scale-factor = [ sign ] digit-sequence.
set-constructor = '[' [ member-designator { ',' member-designator } ] ']'.
set-type = 'set' 'of' base-type.
sign = '+' | '-'.
signed-integer = [ sign ] unsigned-integer.
signed-number = signed-integer | signed-real.
signed-real = [ sign ] unsigned-real.
simple-expression = [ sign ] term f adding-operator term g.
simple-statement = empty-statement | assignment-statement
                 | procedure-statement | goto-statement.
simple-type = ordinal-type | real-type-identifier.
simple-type-identifier = type-identifier.
special-symbol = '+' | '~' | '*' | '/' | '=' | '<' | '>' | '[' | ']'
               | '.' | ',' | ':' |' ;' | '"' | '(' | ')'
               | '<>' | '<=' | '>=' | ' :=' | '..' | word-symbol
statement = [ label ' :' ] ( simple-statement | structured-statement ).
statement-part = compound-statement.
statement-sequence = statement f ';' statement g.
string-character = one-of-a-set-of-implementation-defined-characters.
string-element = apostrophe-image | string-character.
structured-statement = compound-statement | conditional-statement
                     | repetitive-statement | with-statement.
structured-type = new-structured-type | structured-type-identifier.
structured-type-identifier = type-identifier.
subrange-type = constant '..' constant.
tag-field = identifier.
tag-type = ordinal-type-identifier.
term = factor f multiplying-operator factor g.
type-definition = identifier '=' type-denoter.
type-definition-part = [ 'type' type-definition ' ;' { type-definition ';' } ] .
type-denoter = type-identifier | new-type.
type-identifier = identifier.
unpacked-conformant-array-schema =
     'array' '[' index-type-specification { ';' index-type-specification } ']'
     'of' ( type-identifier | conformant-array-schema ).
unpacked-structured-type = array-type | record-type | set-type | file-type.
unsigned-constant = unsigned-number | character-string | constant-identifier | 'nil'.
unsigned-integer = digit-sequence.
unsigned-number = unsigned-integer | unsigned-real.
unsigned-real = digit-sequence '.' fractional-part [ 'e' scale-factor ]
              | digit-sequence 'e' scale-factor.
value-conformant-array-specification = identifier-list ':' conformant-array-schema.
value-parameter-specification = identifier-list ':' type-identifier.
variable-access = entire-variable | component-variable | identified-variable
                | buffer-variable.
variable-conformant-array-specification = 'var' identifier-list ':' conformant-array-schema.
variable-declaration = identifier-list ':' type-denoter.
variable-declaration-part = [ 'var' variable-declaration ' ;' { variable-declaration ';' } ] .
variable-identifier = identifier.
variable-parameter-specification = 'var' identifier-list ':' type-identifier.
variant = case-constant-list ':' '(' field-list ')'.
variant-part = 'case' variant-selector 'of' variant { ';' variant }.
variant-selector = [ tag-field ':' ] tag-type.
while-statement = 'while' Boolean-expression 'do' statement.
with-statement = 'with' record-variable-list 'do' statement.
word-symbol = 'and' | 'array' | 'begin' | 'case' | 'const' | 'div'
            | 'do' | 'downto' | 'else' | 'end' | 'file' | 'for'
            | 'function' | 'goto' | 'if' | 'in' | 'label' | 'mod'
            | 'nil' | 'not' | 'of' | 'or' | 'packed' | 'procedure'
            | 'program' | 'record' | 'repeat' | 'set' | 'then'
            | 'to' | 'type' | 'until' | 'var' | 'while' | 'with'.
write-parameter = expression [ ':' expression [ ':' expression ] ].
write-parameter-list = '(' [ file-variable ',' ] write-parameter
                       { ',' write-parameter } ')'.
 
writeln-parameter-list = [ '(' ( file-variable | write-parameter )
                         { ',' write-parameter } ')' ].

