{2:}{4:}{$C-,A+,D-}{[$C+,D+]}
{:4}program WEAVE(web_file,change_file,tex_file);label 9999;
const{8:}max_bytes=45000;max_names=5000;max_modules=2000;hash_size=353;
buf_size=100;longest_name=400;long_buf_size=500;line_length=80;
max_refs=30000;max_toks=30000;max_texts=2000;max_scraps=1000;
stack_size=200;{:8}type{11:}ASCII_code=0..255;
{:11}{12:}text_file=packed file of char;{:12}{36:}eight_bits=0..255;
sixteen_bits=0..65535;{:36}{38:}name_pointer=0..max_names;
{:38}{47:}xref_number=0..max_refs;{:47}{52:}text_pointer=0..max_texts;
{:52}{201:}mode=0..1;output_state=record end_field:sixteen_bits;
tok_field:sixteen_bits;mode_field:mode;end;{:201}var{9:}history:0..3;
{:9}{13:}xord:array[char]of ASCII_code;xchr:array[ASCII_code]of char;
{:13}{20:}term_out:text_file;{:20}{23:}web_file:text_file;
change_file:text_file;{:23}{25:}tex_file:text_file;
{:25}{27:}buffer:array[0..long_buf_size]of ASCII_code;
{:27}{29:}phase_one:boolean;phase_three:boolean;
{:29}{37:}byte_mem:packed array[0..1,0..max_bytes]of ASCII_code;
byte_start:array[0..max_names]of sixteen_bits;
link:array[0..max_names]of sixteen_bits;
ilk:array[0..max_names]of sixteen_bits;
xref:array[0..max_names]of sixteen_bits;{:37}{39:}name_ptr:name_pointer;
byte_ptr:array[0..1]of 0..max_bytes;
{:39}{45:}module_count:0..max_modules;
changed_module:packed array[0..max_modules]of boolean;
change_exists:boolean;
{:45}{48:}xmem:array[xref_number]of packed record num_field:sixteen_bits
;xlink_field:sixteen_bits;end;xref_ptr:xref_number;
xref_switch,mod_xref_switch:0..10240;
{:48}{53:}tok_mem:packed array[0..max_toks]of sixteen_bits;
tok_start:array[text_pointer]of sixteen_bits;text_ptr:text_pointer;
tok_ptr:0..max_toks;{max_tok_ptr,max_txt_ptr:0..max_toks;}
{:53}{55:}id_first:0..long_buf_size;id_loc:0..long_buf_size;
hash:array[0..hash_size]of sixteen_bits;{:55}{63:}cur_name:name_pointer;
{:63}{65:}mod_text:array[0..longest_name]of ASCII_code;
{:65}{71:}ii:integer;line:integer;other_line:integer;temp_line:integer;
limit:0..long_buf_size;loc:0..long_buf_size;input_has_ended:boolean;
changing:boolean;change_pending:boolean;
{:71}{73:}change_buffer:array[0..buf_size]of ASCII_code;
change_limit:0..buf_size;{:73}{93:}cur_module:name_pointer;
scanning_hex:boolean;{:93}{108:}next_control:eight_bits;
{:108}{114:}lhs,rhs:name_pointer;{:114}{118:}cur_xref:xref_number;
{:118}{121:}out_buf:array[0..line_length]of ASCII_code;
out_ptr:0..line_length;out_line:integer;
{:121}{129:}dig:array[0..4]of 0..9;
{:129}{144:}cat:array[0..max_scraps]of eight_bits;
trans:array[0..max_scraps]of 0..10239;pp:0..max_scraps;
scrap_base:0..max_scraps;scrap_ptr:0..max_scraps;lo_ptr:0..max_scraps;
hi_ptr:0..max_scraps;{max_scr_ptr:0..max_scraps;}
{:144}{177:}{tracing:0..2;}{:177}{202:}cur_state:output_state;
stack:array[1..stack_size]of output_state;stack_ptr:0..stack_size;
{max_stack_ptr:0..stack_size;}{:202}{219:}save_line:integer;
save_place:sixteen_bits;{:219}{229:}this_module:name_pointer;
{:229}{234:}next_xref,this_xref,first_xref,mid_xref:xref_number;
{:234}{240:}k_module:0..max_modules;
{:240}{242:}bucket:array[ASCII_code]of name_pointer;
next_name:name_pointer;c:ASCII_code;h:0..hash_size;
blink:array[0..max_names]of sixteen_bits;
{:242}{244:}cur_depth:eight_bits;cur_byte:0..max_bytes;cur_bank:0..1;
cur_val:sixteen_bits;{max_sort_ptr:0..max_scraps;}
{:244}{246:}collate:array[0..229]of ASCII_code;
{:246}{258:}{trouble_shooting:boolean;ddt:integer;dd:integer;
debug_cycle:integer;debug_skipped:integer;term_in:text_file;}
{:258}{30:}{procedure debug_help;forward;}{:30}{31:}procedure error;
var k,l:0..long_buf_size;
begin{32:}begin if changing then write(term_out,'. (change file ')else
write(term_out,'. (');write_ln(term_out,'l.',line:1,')');
if loc>=limit then l:=limit else l:=loc;
for k:=1 to l do if buffer[k-1]=9 then write(term_out,' ')else write(
term_out,xchr[buffer[k-1]]);write_ln(term_out);
for k:=1 to l do write(term_out,' ');
for k:=l+1 to limit do write(term_out,xchr[buffer[k-1]]);
if buffer[limit]=124 then write(term_out,xchr[124]);write(term_out,' ');
end{:32};break(term_out);history:=2;{debug_skipped:=debug_cycle;
debug_help;}end;{:31}{33:}procedure jump_out;begin goto 9999;end;
{:33}procedure initialize;var{16:}i:0..255;{:16}{40:}wi:0..1;
{:40}{56:}h:0..hash_size;{:56}{247:}c:ASCII_code;
{:247}begin{10:}history:=0;{:10}{14:}xchr[32]:=' ';xchr[33]:='!';
xchr[34]:='"';xchr[35]:='#';xchr[36]:='$';xchr[37]:='%';xchr[38]:='&';
xchr[39]:='''';xchr[40]:='(';xchr[41]:=')';xchr[42]:='*';xchr[43]:='+';
xchr[44]:=',';xchr[45]:='-';xchr[46]:='.';xchr[47]:='/';xchr[48]:='0';
xchr[49]:='1';xchr[50]:='2';xchr[51]:='3';xchr[52]:='4';xchr[53]:='5';
xchr[54]:='6';xchr[55]:='7';xchr[56]:='8';xchr[57]:='9';xchr[58]:=':';
xchr[59]:=';';xchr[60]:='<';xchr[61]:='=';xchr[62]:='>';xchr[63]:='?';
xchr[64]:='@';xchr[65]:='A';xchr[66]:='B';xchr[67]:='C';xchr[68]:='D';
xchr[69]:='E';xchr[70]:='F';xchr[71]:='G';xchr[72]:='H';xchr[73]:='I';
xchr[74]:='J';xchr[75]:='K';xchr[76]:='L';xchr[77]:='M';xchr[78]:='N';
xchr[79]:='O';xchr[80]:='P';xchr[81]:='Q';xchr[82]:='R';xchr[83]:='S';
xchr[84]:='T';xchr[85]:='U';xchr[86]:='V';xchr[87]:='W';xchr[88]:='X';
xchr[89]:='Y';xchr[90]:='Z';xchr[91]:='[';xchr[92]:='\';xchr[93]:=']';
xchr[94]:='^';xchr[95]:='_';xchr[96]:='`';xchr[97]:='a';xchr[98]:='b';
xchr[99]:='c';xchr[100]:='d';xchr[101]:='e';xchr[102]:='f';
xchr[103]:='g';xchr[104]:='h';xchr[105]:='i';xchr[106]:='j';
xchr[107]:='k';xchr[108]:='l';xchr[109]:='m';xchr[110]:='n';
xchr[111]:='o';xchr[112]:='p';xchr[113]:='q';xchr[114]:='r';
xchr[115]:='s';xchr[116]:='t';xchr[117]:='u';xchr[118]:='v';
xchr[119]:='w';xchr[120]:='x';xchr[121]:='y';xchr[122]:='z';
xchr[123]:='{';xchr[124]:='|';xchr[125]:='}';xchr[126]:='~';
xchr[0]:=' ';xchr[127]:=' ';{:14}{17:}for i:=1 to 31 do xchr[i]:=' ';
for i:=128 to 255 do xchr[i]:=' ';
{:17}{18:}for i:=0 to 255 do xord[chr(i)]:=32;
for i:=1 to 255 do xord[xchr[i]]:=i;xord[' ']:=32;
{:18}{21:}rewrite(term_out,'TTY:');{:21}{26:}rewrite(tex_file);
{:26}{41:}for wi:=0 to 1 do begin byte_start[wi]:=0;byte_ptr[wi]:=0;end;
byte_start[2]:=0;name_ptr:=1;{:41}{43:}ilk[0]:=0;{:43}{49:}xref_ptr:=0;
xref_switch:=0;mod_xref_switch:=0;xmem[0].num_field:=0;xref[0]:=0;
{:49}{54:}tok_ptr:=1;text_ptr:=1;tok_start[0]:=1;tok_start[1]:=1;
{max_tok_ptr:=1;max_txt_ptr:=1;}
{:54}{57:}for h:=0 to hash_size-1 do hash[h]:=0;
{:57}{94:}scanning_hex:=false;{:94}{102:}mod_text[0]:=32;
{:102}{124:}out_ptr:=1;out_line:=1;out_buf[1]:=99;
write(tex_file,'\input webma');{:124}{126:}out_buf[0]:=92;
{:126}{145:}scrap_base:=1;scrap_ptr:=0;{max_scr_ptr:=0;}
{:145}{203:}{max_stack_ptr:=0;}{:203}{245:}{max_sort_ptr:=0;}
{:245}{248:}collate[0]:=0;collate[1]:=32;
for c:=1 to 31 do collate[c+1]:=c;for c:=33 to 47 do collate[c]:=c;
for c:=58 to 64 do collate[c-10]:=c;for c:=91 to 94 do collate[c-36]:=c;
collate[59]:=96;for c:=123 to 255 do collate[c-63]:=c;collate[193]:=95;
for c:=97 to 122 do collate[c+97]:=c;
for c:=48 to 57 do collate[c+172]:=c;
{:248}{259:}{trouble_shooting:=true;debug_cycle:=1;debug_skipped:=0;
tracing:=0;trouble_shooting:=false;debug_cycle:=99999;
reset(term_in,'TTY:','/I');}{:259}end;{:2}{24:}procedure open_input;
begin reset(web_file);reset(change_file);end;
{:24}{28:}function input_ln(var f:text_file):boolean;
var final_limit:0..buf_size;begin limit:=0;final_limit:=0;
if eof(f)then input_ln:=false else begin while not eoln(f)do begin
buffer[limit]:=xord[f^];get(f);limit:=limit+1;
if buffer[limit-1]<>32 then final_limit:=limit;
if limit=buf_size then begin while not eoln(f)do get(f);limit:=limit-1;
if final_limit>limit then final_limit:=limit;begin write_ln(term_out);
write(term_out,'! Input line too long');end;loc:=0;error;end;end;
read_ln(f);limit:=final_limit;input_ln:=true;end;end;
{:28}{44:}procedure print_id(p:name_pointer);var k:0..max_bytes;w:0..1;
begin if p>=name_ptr then write(term_out,'IMPOSSIBLE')else begin w:=p
mod 2;
for k:=byte_start[p]to byte_start[p+2]-1 do write(term_out,xchr[byte_mem
[w,k]]);end;end;{:44}{50:}procedure new_xref(p:name_pointer);label 10;
var q:xref_number;m,n:sixteen_bits;
begin if((ilk[p]>3)or(byte_start[p]+1=byte_start[p+2]))and(xref_switch=0
)then goto 10;m:=module_count+xref_switch;xref_switch:=0;q:=xref[p];
if q>0 then begin n:=xmem[q].num_field;
if(n=m)or(n=m+10240)then goto 10 else if m=n+10240 then begin xmem[q].
num_field:=m;goto 10;end;end;
if xref_ptr=max_refs then begin write_ln(term_out);
write(term_out,'! Sorry, ','cross reference',' capacity exceeded');
error;history:=3;jump_out;end else begin xref_ptr:=xref_ptr+1;
xmem[xref_ptr].num_field:=m;end;xmem[xref_ptr].xlink_field:=q;
xref[p]:=xref_ptr;10:end;
{:50}{51:}procedure new_mod_xref(p:name_pointer);var q,r:xref_number;
begin q:=xref[p];r:=0;
if q>0 then begin if mod_xref_switch=0 then while xmem[q].num_field>=
10240 do begin r:=q;q:=xmem[q].xlink_field;
end else if xmem[q].num_field>=10240 then begin r:=q;
q:=xmem[q].xlink_field;end;end;
if xref_ptr=max_refs then begin write_ln(term_out);
write(term_out,'! Sorry, ','cross reference',' capacity exceeded');
error;history:=3;jump_out;end else begin xref_ptr:=xref_ptr+1;
xmem[xref_ptr].num_field:=module_count+mod_xref_switch;end;
xmem[xref_ptr].xlink_field:=q;mod_xref_switch:=0;
if r=0 then xref[p]:=xref_ptr else xmem[r].xlink_field:=xref_ptr;end;
{:51}{58:}function id_lookup(t:eight_bits):name_pointer;label 31;
var i:0..long_buf_size;h:0..hash_size;k:0..max_bytes;w:0..1;
l:0..long_buf_size;p:name_pointer;begin l:=id_loc-id_first;
{59:}h:=buffer[id_first];i:=id_first+1;
while i<id_loc do begin h:=(h+h+buffer[i])mod hash_size;i:=i+1;end{:59};
{60:}p:=hash[h];
while p<>0 do begin if(byte_start[p+2]-byte_start[p]=l)and((ilk[p]=t)or(
(t=0)and(ilk[p]>3)))then{61:}begin i:=id_first;k:=byte_start[p];
w:=p mod 2;while(i<id_loc)and(buffer[i]=byte_mem[w,k])do begin i:=i+1;
k:=k+1;end;if i=id_loc then goto 31;end{:61};p:=link[p];end;p:=name_ptr;
link[p]:=hash[h];hash[h]:=p;31:{:60};
if p=name_ptr then{62:}begin w:=name_ptr mod 2;
if byte_ptr[w]+l>max_bytes then begin write_ln(term_out);
write(term_out,'! Sorry, ','byte memory',' capacity exceeded');error;
history:=3;jump_out;end;
if name_ptr+2>max_names then begin write_ln(term_out);
write(term_out,'! Sorry, ','name',' capacity exceeded');error;
history:=3;jump_out;end;i:=id_first;k:=byte_ptr[w];
while i<id_loc do begin byte_mem[w,k]:=buffer[i];k:=k+1;i:=i+1;end;
byte_ptr[w]:=k;byte_start[name_ptr+2]:=k;name_ptr:=name_ptr+1;ilk[p]:=t;
xref[p]:=0;end{:62};id_lookup:=p;end;
{:58}{66:}function mod_lookup(l:sixteen_bits):name_pointer;label 31;
var c:0..4;j:0..longest_name;k:0..max_bytes;w:0..1;p:name_pointer;
q:name_pointer;begin c:=2;q:=0;p:=ilk[0];
while p<>0 do begin{68:}begin k:=byte_start[p];w:=p mod 2;c:=1;j:=1;
while(k<byte_start[p+2])and(j<=l)and(mod_text[j]=byte_mem[w,k])do begin
k:=k+1;j:=j+1;end;
if k=byte_start[p+2]then if j>l then c:=1 else c:=4 else if j>l then c:=
3 else if mod_text[j]<byte_mem[w,k]then c:=0 else c:=2;end{:68};q:=p;
if c=0 then p:=link[q]else if c=2 then p:=ilk[q]else goto 31;end;
{67:}w:=name_ptr mod 2;k:=byte_ptr[w];
if k+l>max_bytes then begin write_ln(term_out);
write(term_out,'! Sorry, ','byte memory',' capacity exceeded');error;
history:=3;jump_out;end;
if name_ptr>max_names-2 then begin write_ln(term_out);
write(term_out,'! Sorry, ','name',' capacity exceeded');error;
history:=3;jump_out;end;p:=name_ptr;
if c=0 then link[q]:=p else ilk[q]:=p;link[p]:=0;ilk[p]:=0;xref[p]:=0;
c:=1;for j:=1 to l do byte_mem[w,k+j-1]:=mod_text[j];byte_ptr[w]:=k+l;
byte_start[name_ptr+2]:=k+l;name_ptr:=name_ptr+1;{:67};
31:if c<>1 then begin begin if not phase_one then begin write_ln(
term_out);write(term_out,'! Incompatible section names');error;end;end;
p:=0;end;mod_lookup:=p;end;
{:66}{69:}function prefix_lookup(l:sixteen_bits):name_pointer;
var c:0..4;count:0..max_names;j:0..longest_name;k:0..max_bytes;w:0..1;
p:name_pointer;q:name_pointer;r:name_pointer;begin q:=0;p:=ilk[0];
count:=0;r:=0;while p<>0 do begin{68:}begin k:=byte_start[p];w:=p mod 2;
c:=1;j:=1;
while(k<byte_start[p+2])and(j<=l)and(mod_text[j]=byte_mem[w,k])do begin
k:=k+1;j:=j+1;end;
if k=byte_start[p+2]then if j>l then c:=1 else c:=4 else if j>l then c:=
3 else if mod_text[j]<byte_mem[w,k]then c:=0 else c:=2;end{:68};
if c=0 then p:=link[p]else if c=2 then p:=ilk[p]else begin r:=p;
count:=count+1;q:=ilk[p];p:=link[p];end;if p=0 then begin p:=q;q:=0;end;
end;if count<>1 then if count=0 then begin if not phase_one then begin
write_ln(term_out);write(term_out,'! Name does not match');error;end;
end else begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Ambiguous prefix');error;end;end;prefix_lookup:=r;end;
{:69}{74:}function lines_dont_match:boolean;label 10;var k:0..buf_size;
begin lines_dont_match:=true;if change_limit<>limit then goto 10;
if limit>0 then for k:=0 to limit-1 do if change_buffer[k]<>buffer[k]
then goto 10;lines_dont_match:=false;10:end;
{:74}{75:}procedure prime_the_change_buffer;label 22,30,10;
var k:0..buf_size;begin change_limit:=0;
{76:}while true do begin line:=line+1;
if not input_ln(change_file)then goto 10;if limit<2 then goto 22;
if buffer[0]<>64 then goto 22;
if(buffer[1]>=88)and(buffer[1]<=90)then buffer[1]:=buffer[1]+32;
if buffer[1]=120 then goto 30;
if(buffer[1]=121)or(buffer[1]=122)then begin loc:=2;
begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Where is the matching @x?');error;end;end;end;22:end;
30:{:76};{77:}repeat line:=line+1;
if not input_ln(change_file)then begin begin if not phase_one then begin
write_ln(term_out);write(term_out,'! Change file ended after @x');error;
end;end;goto 10;end;until limit>0;{:77};{78:}begin change_limit:=limit;
if limit>0 then for k:=0 to limit-1 do change_buffer[k]:=buffer[k];
end{:78};10:end;{:75}{79:}procedure check_change;label 10;var n:integer;
k:0..buf_size;begin if lines_dont_match then goto 10;
change_pending:=false;
if not changed_module[module_count]then begin loc:=0;buffer[limit]:=33;
while(buffer[loc]=32)or(buffer[loc]=9)do loc:=loc+1;buffer[limit]:=32;
if buffer[loc]=64 then if(buffer[loc+1]=42)or(buffer[loc+1]=32)or(buffer
[loc+1]=9)then change_pending:=true;
if not change_pending then changed_module[module_count]:=true;end;n:=0;
while true do begin changing:=not changing;temp_line:=other_line;
other_line:=line;line:=temp_line;line:=line+1;
if not input_ln(change_file)then begin begin if not phase_one then begin
write_ln(term_out);write(term_out,'! Change file ended before @y');
error;end;end;change_limit:=0;changing:=not changing;
temp_line:=other_line;other_line:=line;line:=temp_line;goto 10;end;
{80:}if limit>1 then if buffer[0]=64 then begin if(buffer[1]>=88)and(
buffer[1]<=90)then buffer[1]:=buffer[1]+32;
if(buffer[1]=120)or(buffer[1]=122)then begin loc:=2;
begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Where is the matching @y?');error;end;end;
end else if buffer[1]=121 then begin if n>0 then begin loc:=2;
begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Hmm... ',n:1,' of the preceding lines failed to match'
);error;end;end;end;goto 10;end;end{:80};{78:}begin change_limit:=limit;
if limit>0 then for k:=0 to limit-1 do change_buffer[k]:=buffer[k];
end{:78};changing:=not changing;temp_line:=other_line;other_line:=line;
line:=temp_line;line:=line+1;
if not input_ln(web_file)then begin begin if not phase_one then begin
write_ln(term_out);write(term_out,'! WEB file ended during a change');
error;end;end;input_has_ended:=true;goto 10;end;
if lines_dont_match then n:=n+1;end;10:end;
{:79}{81:}procedure reset_input;begin open_input;line:=0;other_line:=0;
changing:=true;prime_the_change_buffer;changing:=not changing;
temp_line:=other_line;other_line:=line;line:=temp_line;limit:=0;loc:=1;
buffer[0]:=32;input_has_ended:=false;end;{:81}{82:}procedure get_line;
label 20;begin 20:if changing then{84:}begin line:=line+1;
if not input_ln(change_file)then begin begin if not phase_one then begin
write_ln(term_out);write(term_out,'! Change file ended without @z');
error;end;end;buffer[0]:=64;buffer[1]:=122;limit:=2;end;
if limit>0 then begin if change_pending then begin loc:=0;
buffer[limit]:=33;while(buffer[loc]=32)or(buffer[loc]=9)do loc:=loc+1;
buffer[limit]:=32;
if buffer[loc]=64 then if(buffer[loc+1]=42)or(buffer[loc+1]=32)or(buffer
[loc+1]=9)then change_pending:=false;
if change_pending then begin changed_module[module_count]:=true;
change_pending:=false;end;end;buffer[limit]:=32;
if buffer[0]=64 then begin if(buffer[1]>=88)and(buffer[1]<=90)then
buffer[1]:=buffer[1]+32;
if(buffer[1]=120)or(buffer[1]=121)then begin loc:=2;
begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Where is the matching @z?');error;end;end;
end else if buffer[1]=122 then begin prime_the_change_buffer;
changing:=not changing;temp_line:=other_line;other_line:=line;
line:=temp_line;end;end;end;end{:84};
if not changing then begin{83:}begin line:=line+1;
if not input_ln(web_file)then input_has_ended:=true else if limit=
change_limit then if buffer[0]=change_buffer[0]then if change_limit>0
then check_change;end{:83};if changing then goto 20;end;loc:=0;
buffer[limit]:=32;end;
{:82}{87:}function control_code(c:ASCII_code):eight_bits;
begin case c of 64:control_code:=64;39:control_code:=12;
34:control_code:=13;36:control_code:=135;32,9,42:control_code:=147;
61:control_code:=2;92:control_code:=3;68,100:control_code:=144;
70,102:control_code:=143;123:control_code:=9;125:control_code:=10;
80,112:control_code:=145;38:control_code:=136;60:control_code:=146;
62:begin begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Extra @>');error;end;end;control_code:=0;end;
84,116:control_code:=134;33:control_code:=126;63:control_code:=125;
94:control_code:=131;58:control_code:=132;46:control_code:=133;
44:control_code:=137;124:control_code:=138;47:control_code:=139;
35:control_code:=140;43:control_code:=141;59:control_code:=142;
{88:}{48,49,50:begin tracing:=c-48;control_code:=0;end;}
{:88}others:begin begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Unknown control code');error;end;end;control_code:=0;
end end;end;{:87}{89:}procedure skip_limbo;label 10;var c:ASCII_code;
begin while true do if loc>limit then begin get_line;
if input_has_ended then goto 10;end else begin buffer[limit+1]:=64;
while buffer[loc]<>64 do loc:=loc+1;if loc<=limit then begin loc:=loc+2;
c:=buffer[loc-1];if(c=32)or(c=9)or(c=42)then goto 10;end;end;10:end;
{:89}{90:}function skip_TeX:eight_bits;label 30;var c:eight_bits;
begin while true do begin if loc>limit then begin get_line;
if input_has_ended then begin c:=147;goto 30;end;end;
buffer[limit+1]:=64;repeat c:=buffer[loc];loc:=loc+1;
if c=124 then goto 30;until c=64;
if loc<=limit then begin c:=control_code(buffer[loc]);loc:=loc+1;
goto 30;end;end;30:skip_TeX:=c;end;
{:90}{91:}function skip_comment(bal:eight_bits):eight_bits;label 30;
var c:ASCII_code;
begin while true do begin if loc>limit then begin get_line;
if input_has_ended then begin bal:=0;goto 30;end;end;c:=buffer[loc];
loc:=loc+1;if c=124 then goto 30;{92:}if c=64 then begin c:=buffer[loc];
if(c<>32)and(c<>9)and(c<>42)then loc:=loc+1 else begin loc:=loc-1;
bal:=0;goto 30;
end end else if(c=92)and(buffer[loc]<>64)then loc:=loc+1 else if c=123
then bal:=bal+1 else if c=125 then begin bal:=bal-1;
if bal=0 then goto 30;end{:92};end;30:skip_comment:=bal;end;
{:91}{95:}function get_next:eight_bits;label 20,30,31;var c:eight_bits;
d:eight_bits;j,k:0..longest_name;
begin 20:if loc>limit then begin get_line;
if input_has_ended then begin c:=147;goto 31;end;end;c:=buffer[loc];
loc:=loc+1;
if scanning_hex then{96:}if((c>=48)and(c<=57))or((c>=65)and(c<=70))then
goto 31 else scanning_hex:=false{:96};
case c of 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85
,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111
,112,113,114,115,116,117,118,119,120,121,122:{98:}begin if((c=69)or(c=
101))and(loc>1)then if(buffer[loc-2]<=57)and(buffer[loc-2]>=48)then c:=
128;if c<>128 then begin loc:=loc-1;id_first:=loc;repeat loc:=loc+1;
d:=buffer[loc];
until((d<48)or((d>57)and(d<65))or((d>90)and(d<97))or(d>122))and(d<>95);
c:=130;id_loc:=loc;end;end{:98};39,34:{99:}begin id_first:=loc-1;
repeat d:=buffer[loc];loc:=loc+1;
if loc>limit then begin begin if not phase_one then begin write_ln(
term_out);write(term_out,'! String constant didn''t end');error;end;end;
loc:=limit;d:=c;end;until d=c;id_loc:=loc;c:=129;end{:99};
64:{100:}begin c:=control_code(buffer[loc]);loc:=loc+1;
if c=126 then begin xref_switch:=10240;goto 20;
end else if c=125 then begin xref_switch:=0;goto 20;
end else if(c<=134)and(c>=131)then{106:}begin id_first:=loc;
buffer[limit+1]:=64;while buffer[loc]<>64 do loc:=loc+1;id_loc:=loc;
if loc>limit then begin begin if not phase_one then begin write_ln(
term_out);write(term_out,'! Control text didn''t end');error;end;end;
loc:=limit;end else begin loc:=loc+2;
if buffer[loc-1]<>62 then begin if not phase_one then begin write_ln(
term_out);
write(term_out,'! Control codes are forbidden in control text');error;
end;end;end;
end{:106}else if c=13 then scanning_hex:=true else if c=146 then{101:}
begin{103:}k:=0;while true do begin if loc>limit then begin get_line;
if input_has_ended then begin begin if not phase_one then begin write_ln
(term_out);write(term_out,'! Input ended in section name');error;end;
end;loc:=1;goto 30;end;end;d:=buffer[loc];
{104:}if d=64 then begin d:=buffer[loc+1];if d=62 then begin loc:=loc+2;
goto 30;end;
if(d=32)or(d=9)or(d=42)then begin begin if not phase_one then begin
write_ln(term_out);write(term_out,'! Section name didn''t end');error;
end;end;goto 30;end;k:=k+1;mod_text[k]:=64;loc:=loc+1;end{:104};
loc:=loc+1;if k<longest_name-1 then k:=k+1;
if(d=32)or(d=9)then begin d:=32;if mod_text[k-1]=32 then k:=k-1;end;
mod_text[k]:=d;end;
30:{105:}if k>=longest_name-2 then begin begin write_ln(term_out);
write(term_out,'! Section name too long: ');end;
for j:=1 to 25 do write(term_out,xchr[mod_text[j]]);
write(term_out,'...');if history=0 then history:=1;end{:105};
if(mod_text[k]=32)and(k>0)then k:=k-1{:103};
if k>3 then begin if(mod_text[k]=46)and(mod_text[k-1]=46)and(mod_text[k
-2]=46)then cur_module:=prefix_lookup(k-3)else cur_module:=mod_lookup(k)
;end else cur_module:=mod_lookup(k);xref_switch:=0;
end{:101}else if c=2 then{107:}begin id_first:=loc;loc:=loc+1;
buffer[limit+1]:=64;buffer[limit+2]:=62;
while(buffer[loc]<>64)or(buffer[loc+1]<>62)do loc:=loc+1;
if loc>=limit then begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Verbatim string didn''t end');error;end;end;
id_loc:=loc;loc:=loc+2;end{:107};end{:100};
{97:}46:if buffer[loc]=46 then begin if loc<=limit then begin c:=32;
loc:=loc+1;end;
end else if buffer[loc]=41 then begin if loc<=limit then begin c:=93;
loc:=loc+1;end;end;
58:if buffer[loc]=61 then begin if loc<=limit then begin c:=24;
loc:=loc+1;end;end;
61:if buffer[loc]=61 then begin if loc<=limit then begin c:=30;
loc:=loc+1;end;end;
62:if buffer[loc]=61 then begin if loc<=limit then begin c:=29;
loc:=loc+1;end;end;
60:if buffer[loc]=61 then begin if loc<=limit then begin c:=28;
loc:=loc+1;end;
end else if buffer[loc]=62 then begin if loc<=limit then begin c:=26;
loc:=loc+1;end;end;
40:if buffer[loc]=42 then begin if loc<=limit then begin c:=9;
loc:=loc+1;end;
end else if buffer[loc]=46 then begin if loc<=limit then begin c:=91;
loc:=loc+1;end;end;
42:if buffer[loc]=41 then begin if loc<=limit then begin c:=10;
loc:=loc+1;end;end;{:97}32,9:goto 20;
125:begin begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Extra }');error;end;end;goto 20;end;
others:if c>=128 then goto 20 else end;
31:{if trouble_shooting then debug_help;}get_next:=c;end;
{:95}{111:}procedure Pascal_xref;label 10;var p:name_pointer;
begin while next_control<143 do begin if(next_control>=130)and(
next_control<=133)then begin p:=id_lookup(next_control-130);new_xref(p);
if(ilk[p]=17)or(ilk[p]=22)then xref_switch:=10240;end;
next_control:=get_next;
if(next_control=124)or(next_control=123)then goto 10;end;10:end;
{:111}{112:}procedure outer_xref;var bal:eight_bits;
begin while next_control<143 do if next_control<>123 then Pascal_xref
else begin bal:=skip_comment(1);next_control:=124;
while bal>0 do begin Pascal_xref;
if next_control=124 then bal:=skip_comment(bal)else bal:=0;end;end;end;
{:112}{119:}procedure mod_check(p:name_pointer);
begin if p>0 then begin mod_check(link[p]);cur_xref:=xref[p];
if xmem[cur_xref].num_field<10240 then begin begin write_ln(term_out);
write(term_out,'! Never defined: <');end;print_id(p);
write(term_out,'>');if history=0 then history:=1;end;
while xmem[cur_xref].num_field>=10240 do cur_xref:=xmem[cur_xref].
xlink_field;if cur_xref=0 then begin begin write_ln(term_out);
write(term_out,'! Never used: <');end;print_id(p);write(term_out,'>');
if history=0 then history:=1;end;mod_check(ilk[p]);end;end;
{:119}{122:}procedure flush_buffer(b:eight_bits;
per_cent,carryover:boolean);label 30,31;var j,k:0..line_length;
begin j:=b;if not per_cent then while true do begin if j=0 then goto 30;
if out_buf[j]<>32 then goto 30;j:=j-1;end;
30:for k:=1 to j do write(tex_file,xchr[out_buf[k]]);
if per_cent then write(tex_file,xchr[37]);write_ln(tex_file);
out_line:=out_line+1;
if carryover then for k:=1 to j do if out_buf[k]=37 then if(k=1)or(
out_buf[k-1]<>92)then begin out_buf[b]:=37;b:=b-1;goto 31;end;
31:if(b<out_ptr)then for k:=b+1 to out_ptr do out_buf[k-b]:=out_buf[k];
out_ptr:=out_ptr-b;end;{:122}{123:}procedure finish_line;label 10;
var k:0..buf_size;
begin if out_ptr>0 then flush_buffer(out_ptr,false,false)else begin for
k:=0 to limit do if(buffer[k]<>32)and(buffer[k]<>9)then goto 10;
flush_buffer(0,false,false);end;10:end;{:123}{127:}procedure break_out;
label 10;var k:0..line_length;d:ASCII_code;begin k:=out_ptr;
while true do begin if k=0 then{128:}begin begin write_ln(term_out);
write(term_out,'! Line had to be broken (output l.',out_line:1);end;
write_ln(term_out,'):');
for k:=1 to out_ptr-1 do write(term_out,xchr[out_buf[k]]);
write_ln(term_out);if history=0 then history:=1;
flush_buffer(out_ptr-1,true,true);goto 10;end{:128};d:=out_buf[k];
if d=32 then begin flush_buffer(k,false,true);goto 10;end;
if(d=92)and(out_buf[k-1]<>92)then begin flush_buffer(k-1,true,true);
goto 10;end;k:=k-1;end;10:end;{:127}{130:}procedure out_mod(m:integer);
var k:0..5;a:integer;begin k:=0;a:=m;repeat dig[k]:=a mod 10;
a:=a div 10;k:=k+1;until a=0;repeat k:=k-1;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=dig[k]+48;end;until k=0;
if changed_module[m]then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=42;end;end;
{:130}{131:}procedure out_name(p:name_pointer);var k:0..max_bytes;
w:0..1;begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=123;end;w:=p mod 2;
for k:=byte_start[p]to byte_start[p+2]-1 do begin if byte_mem[w,k]=95
then begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;end;begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=byte_mem[w,k];end;end;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=125;end;end;{:131}{132:}procedure copy_limbo;label 10;
var c:ASCII_code;
begin while true do if loc>limit then begin finish_line;get_line;
if input_has_ended then goto 10;end else begin buffer[limit+1]:=64;
{133:}while buffer[loc]<>64 do begin begin if out_ptr=line_length then
break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=buffer[loc];end;
loc:=loc+1;end;if loc<=limit then begin loc:=loc+2;c:=buffer[loc-1];
if(c=32)or(c=9)or(c=42)then goto 10;
if(c<>122)and(c<>90)then begin begin if out_ptr=line_length then
break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=64;end;
if c<>64 then begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Double @ required outside of sections');error;end;end;
end;end{:133};end;10:end;{:132}{134:}function copy_TeX:eight_bits;
label 30;var c:eight_bits;
begin while true do begin if loc>limit then begin finish_line;get_line;
if input_has_ended then begin c:=147;goto 30;end;end;
buffer[limit+1]:=64;{135:}repeat c:=buffer[loc];loc:=loc+1;
if c=124 then goto 30;
if c<>64 then begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=c;end;
if(out_ptr=1)and((c=32)or(c=9))then out_ptr:=out_ptr-1;end;until c=64;
if loc<=limit then begin c:=control_code(buffer[loc]);loc:=loc+1;
goto 30;end{:135};end;30:copy_TeX:=c;end;
{:134}{136:}function copy_comment(bal:eight_bits):eight_bits;label 30;
var c:ASCII_code;
begin while true do begin if loc>limit then begin get_line;
if input_has_ended then begin begin if not phase_one then begin write_ln
(term_out);write(term_out,'! Input ended in mid-comment');error;end;end;
loc:=1;{138:}begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;end;
repeat begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;end;
bal:=bal-1;until bal=0;goto 30;{:138};end;end;c:=buffer[loc];loc:=loc+1;
if c=124 then goto 30;
begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=c;tok_ptr:=tok_ptr+1;end;
{137:}if c=64 then begin loc:=loc+1;
if buffer[loc-1]<>64 then begin begin if not phase_one then begin
write_ln(term_out);write(term_out,'! Illegal use of @ in comment');
error;end;end;loc:=loc-2;tok_ptr:=tok_ptr-1;
{138:}begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;end;
repeat begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;end;
bal:=bal-1;until bal=0;goto 30;{:138};end;
end else if(c=92)and(buffer[loc]<>64)then begin begin if tok_ptr+2>
max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=buffer[loc];
tok_ptr:=tok_ptr+1;end;loc:=loc+1;
end else if c=123 then bal:=bal+1 else if c=125 then begin bal:=bal-1;
if bal=0 then goto 30;end{:137};end;30:copy_comment:=bal;end;
{:136}{140:}{procedure print_cat(c:eight_bits);
begin case c of 1:write(term_out,'simp');2:write(term_out,'math');
3:write(term_out,'intro');4:write(term_out,'open');
5:write(term_out,'beginning');6:write(term_out,'close');
7:write(term_out,'alpha');8:write(term_out,'omega');
9:write(term_out,'semi');10:write(term_out,'terminator');
11:write(term_out,'stmt');12:write(term_out,'cond');
13:write(term_out,'clause');14:write(term_out,'colon');
15:write(term_out,'exp');16:write(term_out,'proc');
17:write(term_out,'casehead');18:write(term_out,'recordhead');
19:write(term_out,'varhead');20:write(term_out,'elsie');
21:write(term_out,'casey');22:write(term_out,'module');
others:write(term_out,'UNKNOWN')end;end;}
{:140}{146:}{procedure print_text(p:text_pointer);var j:0..max_toks;
r:0..10239;
begin if p>=text_ptr then write(term_out,'BAD')else for j:=tok_start[p]
to tok_start[p+1]-1 do begin r:=tok_mem[j]mod 10240;
case tok_mem[j]div 10240 of 1:begin write(term_out,'\\',xchr[123]);
print_id(r);write(term_out,xchr[125]);end;
2:begin write(term_out,'\&',xchr[123]);print_id(r);
write(term_out,xchr[125]);end;3:begin write(term_out,'<');print_id(r);
write(term_out,'>');end;4:write(term_out,'[[',r:1,']]');
5:write(term_out,'|[[',r:1,']]|');
others:[147:]case r of 131:write(term_out,'\mathbin',xchr[123]);
132:write(term_out,'\mathrel',xchr[123]);
133:write(term_out,'\mathop',xchr[123]);134:write(term_out,'[ccancel]');
135:write(term_out,'[cancel]');136:write(term_out,'[indent]');
137:write(term_out,'[outdent]');139:write(term_out,'[backup]');
138:write(term_out,'[opt]');140:write(term_out,'[break]');
141:write(term_out,'[force]');142:write(term_out,'[fforce]');
143:write(term_out,'[quit]');others:write(term_out,xchr[r])end[:147]end;
end;end;}{:146}{172:}procedure red(j:sixteen_bits;k:eight_bits;
c:eight_bits;d:integer);var i:0..max_scraps;begin cat[j]:=c;
trans[j]:=text_ptr;text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;
if k>1 then begin for i:=j+k to lo_ptr do begin cat[i-k+1]:=cat[i];
trans[i-k+1]:=trans[i];end;lo_ptr:=lo_ptr-k+1;end;
{173:}if pp+d>=scrap_base then pp:=pp+d else pp:=scrap_base{:173};end;
{:172}{174:}procedure sq(j:sixteen_bits;k:eight_bits;c:eight_bits;
d:integer);var i:0..max_scraps;begin if k=1 then begin cat[j]:=c;
{173:}if pp+d>=scrap_base then pp:=pp+d else pp:=scrap_base{:173};
end else begin for i:=j to j+k-1 do begin tok_mem[tok_ptr]:=40960+trans[
i];tok_ptr:=tok_ptr+1;end;red(j,k,c,d);end;end;
{:174}{178:}{procedure prod(n:eight_bits);var k:1..max_scraps;
begin if tracing=2 then begin begin write_ln(term_out);
write(term_out,n:1,':');end;
for k:=scrap_base to lo_ptr do begin if k=pp then write(term_out,'*')
else write(term_out,' ');print_cat(cat[k]);end;
if hi_ptr<=scrap_ptr then write(term_out,'...');end;end;}
{:178}{179:}{150:}procedure five_cases;label 31;
begin case cat[pp]of 5:{152:}if cat[pp+1]=6 then begin if(cat[pp+2]=10)
or(cat[pp+2]=11)then begin sq(pp,3,11,-2);{prod(5)};goto 31;end;
end else if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,5,-1);
{prod(6)};goto 31;end{:152};
3:{159:}if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=138;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=55;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,11,-2);
{prod(17)};goto 31;end{:159};
2:{160:}if cat[pp+1]=6 then begin tok_mem[tok_ptr]:=36;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;red(pp,1,11,-2);{prod(18)};
goto 31;end else if cat[pp+1]=14 then begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,3,-3);
{prod(19)};goto 31;end else if cat[pp+1]=2 then begin sq(pp,2,2,-1);
{prod(20)};goto 31;end else if cat[pp+1]=1 then begin sq(pp,2,2,-1);
{prod(21)};goto 31;
end else if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=36;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=136;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=137;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
red(pp,2,11,-2);{prod(22)};goto 31;
end else if cat[pp+1]=10 then begin tok_mem[tok_ptr]:=36;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,11,-2);
{prod(23)};goto 31;end{:160};
4:{162:}if(cat[pp+1]=17)and(cat[pp+2]=6)then begin tok_mem[tok_ptr]:=
40960+trans[pp];tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=36;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=137;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;red(pp,3,2,-1);
{prod(26)};goto 31;
end else if cat[pp+1]=6 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=44;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,2,-1);
{prod(27)};goto 31;
end else if cat[pp+1]=2 then{163:}begin if(cat[pp+2]=17)and(cat[pp+3]=6)
then begin tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+2];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=137;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=36;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+3];
tok_ptr:=tok_ptr+1;red(pp,4,2,-1);{prod(28)};goto 31;
end else if cat[pp+2]=6 then begin sq(pp,3,2,-1);{prod(29)};goto 31;
end else if cat[pp+2]=14 then begin sq(pp+1,2,2,0);{prod(30)};goto 31;
end else if cat[pp+2]=16 then begin if cat[pp+3]=3 then begin tok_mem[
tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=133;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;red(pp+1,3,2,0);{prod(31)};
goto 31;end;
end else if cat[pp+2]=9 then begin tok_mem[tok_ptr]:=40960+trans[pp+1];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+2];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=44;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=138;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=53;tok_ptr:=tok_ptr+1;
red(pp+1,2,2,0);{prod(32)};goto 31;
end else if cat[pp+2]=19 then begin if cat[pp+3]=3 then begin tok_mem[
tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=133;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;red(pp+1,3,2,0);{prod(31)};
goto 31;end;end;
end{:163}else if cat[pp+1]=16 then begin if cat[pp+2]=3 then begin
tok_mem[tok_ptr]:=133;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+1];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;
red(pp+1,2,2,0);{prod(34)};goto 31;end;
end else if cat[pp+1]=1 then begin sq(pp+1,1,2,0);{prod(35)};goto 31;
end else if(cat[pp+1]=11)and(cat[pp+2]=6)then begin tok_mem[tok_ptr]:=
40960+trans[pp];tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=36;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=36;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+2];
tok_ptr:=tok_ptr+1;red(pp,3,2,-1);{prod(36)};goto 31;
end else if cat[pp+1]=19 then begin if cat[pp+2]=3 then begin tok_mem[
tok_ptr]:=133;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+1];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;
red(pp+1,2,2,0);{prod(37)};goto 31;end;end{:162};
1:{167:}if cat[pp+1]=6 then begin sq(pp,1,11,-2);{prod(43)};goto 31;
end else if cat[pp+1]=14 then begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,3,-3);
{prod(44)};goto 31;end else if cat[pp+1]=2 then begin sq(pp,2,2,-1);
{prod(45)};goto 31;end else if cat[pp+1]=22 then begin sq(pp,2,22,0);
{prod(46)};goto 31;end else if cat[pp+1]=1 then begin sq(pp,2,1,-2);
{prod(47)};goto 31;end else if cat[pp+1]=10 then begin sq(pp,2,11,-2);
{prod(48)};goto 31;end{:167};others:end;pp:=pp+1;31:end;
procedure alpha_cases;label 31;
begin{151:}if cat[pp+1]=2 then begin if cat[pp+2]=14 then begin sq(pp+1,
2,2,0);{prod(1)};goto 31;
end else if cat[pp+2]=8 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=32;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=136;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;red(pp,3,13,-2);
{prod(2)};goto 31;end;
end else if cat[pp+1]=8 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=136;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,13,-2);
{prod(3)};goto 31;end else if cat[pp+1]=1 then begin sq(pp+1,1,2,0);
{prod(4)};goto 31;end{:151};pp:=pp+1;31:end;
{:150}function translate:text_pointer;label 30,31;var i:1..max_scraps;
j:0..max_scraps;k:0..long_buf_size;begin pp:=scrap_base;lo_ptr:=pp-1;
hi_ptr:=pp;{182:}{if tracing=2 then begin begin write_ln(term_out);
write(term_out,'Tracing after l.',line:1,':');end;
if history=0 then history:=1;if loc>50 then begin write(term_out,'...');
for k:=loc-50 to loc do write(term_out,xchr[buffer[k-1]]);
end else for k:=1 to loc do write(term_out,xchr[buffer[k-1]]);end}
{:182};
{175:}while true do begin{176:}if lo_ptr<pp+3 then begin repeat if
hi_ptr<=scrap_ptr then begin lo_ptr:=lo_ptr+1;cat[lo_ptr]:=cat[hi_ptr];
trans[lo_ptr]:=trans[hi_ptr];hi_ptr:=hi_ptr+1;end;
until(hi_ptr>scrap_ptr)or(lo_ptr=pp+3);
for i:=lo_ptr+1 to pp+3 do cat[i]:=0;end{:176};
if(tok_ptr+8>max_toks)or(text_ptr+4>max_texts)then begin{if tok_ptr>
max_tok_ptr then max_tok_ptr:=tok_ptr;
if text_ptr>max_txt_ptr then max_txt_ptr:=text_ptr;}
begin write_ln(term_out);
write(term_out,'! Sorry, ','token/text',' capacity exceeded');error;
history:=3;jump_out;end;end;if pp>lo_ptr then goto 30;
{149:}if cat[pp]<=7 then if cat[pp]<7 then five_cases else alpha_cases
else begin case cat[pp]of 17:{153:}if cat[pp+1]=21 then begin if cat[pp
+2]=13 then begin tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=137;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;red(pp,3,17,0);
{prod(7)};goto 31;end;
end else if cat[pp+1]=6 then begin if cat[pp+2]=10 then begin tok_mem[
tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=137;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;red(pp,3,11,-2);
{prod(8)};goto 31;end;
end else if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,17,0);
{prod(9)};goto 31;end{:153};
21:{154:}if cat[pp+1]=13 then begin sq(pp,2,17,0);{prod(10)};goto 31;
end{:154};
13:{155:}if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=137;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
red(pp,2,11,-2);{prod(11)};goto 31;end{:155};
12:{156:}if(cat[pp+1]=13)and(cat[pp+2]=11)then if cat[pp+3]=20 then
begin tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+3];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;
tok_ptr:=tok_ptr+1;red(pp,4,13,-2);{prod(12)};goto 31;
end else begin tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=137;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
red(pp,3,11,-2);{prod(13)};goto 31;end{:156};
20:{157:}begin sq(pp,1,3,-3);{prod(14)};goto 31;end{:157};
15:{158:}if cat[pp+1]=2 then begin if cat[pp+2]=1 then if cat[pp+3]<>1
then begin tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;red(pp,3,2,-1);{prod(15)};
goto 31;end;
end else if cat[pp+1]=1 then if cat[pp+2]<>1 then begin tok_mem[tok_ptr]
:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;red(pp,2,2,-1);{prod(16)};
goto 31;end{:158};
22:{161:}if(cat[pp+1]=10)or(cat[pp+1]=9)then begin tok_mem[tok_ptr]:=
40960+trans[pp];tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+1];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
red(pp,2,11,-2);{prod(24)};goto 31;end else begin sq(pp,1,1,-2);
{prod(25)};goto 31;end{:161};
16:{164:}if cat[pp+1]=5 then begin if(cat[pp+2]=6)and(cat[pp+3]=10)then
begin tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=137;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+1];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+2];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+3];
tok_ptr:=tok_ptr+1;red(pp,4,11,-2);{prod(38)};goto 31;end;
end else if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,16,-2);
{prod(39)};goto 31;end{:164};
18:{165:}if(cat[pp+1]=3)and(cat[pp+2]=21)then begin tok_mem[tok_ptr]:=
40960+trans[pp];tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+1];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;red(pp,3,21,-2);
{prod(40)};goto 31;end else begin tok_mem[tok_ptr]:=136;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp];tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;red(pp,1,17,0);{prod(41)};
goto 31;end{:165};9:{166:}begin sq(pp,1,10,-3);{prod(42)};goto 31;
end{:166};
11:{168:}if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,11,-2);
{prod(49)};goto 31;end{:168};10:{169:}begin sq(pp,1,11,-2);{prod(50)};
goto 31;end{:169};19:{170:}if cat[pp+1]=5 then begin sq(pp,1,11,-2);
{prod(51)};goto 31;
end else if cat[pp+1]=2 then begin if cat[pp+2]=14 then begin tok_mem[
tok_ptr]:=36;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=40960+trans[pp+1];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+2];tok_ptr:=tok_ptr+1;red(pp+1,2,3,+1);
{prod(52)};goto 31;end;
end else if cat[pp+1]=1 then begin if cat[pp+2]=14 then begin sq(pp+1,2,
3,+1);{prod(53)};goto 31;end;
end else if cat[pp+1]=11 then begin tok_mem[tok_ptr]:=40960+trans[pp];
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=140;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=40960+trans[pp+1];tok_ptr:=tok_ptr+1;red(pp,2,19,-2);
{prod(54)};goto 31;end{:170};others:end;pp:=pp+1;31:end{:149};end;
30:{:175};
if(lo_ptr=scrap_base)and(cat[lo_ptr]<>2)then translate:=trans[lo_ptr]
else{180:}begin{181:}{if(lo_ptr>scrap_base)and(tracing=1)then begin
begin write_ln(term_out);
write(term_out,'Irreducible scrap sequence in section ',module_count:1);
end;write_ln(term_out,':');if history=0 then history:=1;
for j:=scrap_base to lo_ptr do begin write(term_out,' ');
print_cat(cat[j]);end;end;}{:181};
for j:=scrap_base to lo_ptr do begin if j<>scrap_base then begin tok_mem
[tok_ptr]:=32;tok_ptr:=tok_ptr+1;end;
if cat[j]=2 then begin tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;end;
tok_mem[tok_ptr]:=40960+trans[j];tok_ptr:=tok_ptr+1;
if cat[j]=2 then begin tok_mem[tok_ptr]:=36;tok_ptr:=tok_ptr+1;end;
if tok_ptr+6>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;end;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;translate:=text_ptr-1;end{:180};end;
{:179}{183:}{195:}procedure app_comment;begin text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;
if(scrap_ptr<scrap_base)or(cat[scrap_ptr]<8)or(cat[scrap_ptr]>10)then
begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=10;trans[scrap_ptr]:=0;
end else begin tok_mem[tok_ptr]:=40960+trans[scrap_ptr];
tok_ptr:=tok_ptr+1;end;tok_mem[tok_ptr]:=text_ptr+40959;
tok_ptr:=tok_ptr+1;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;{:195}{196:}procedure app_octal;
begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=79;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=123;tok_ptr:=tok_ptr+1;
while(buffer[loc]>=48)and(buffer[loc]<=55)do begin begin if tok_ptr+2>
max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=buffer[loc];
tok_ptr:=tok_ptr+1;end;loc:=loc+1;end;begin tok_mem[tok_ptr]:=125;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;end;procedure app_hex;
begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=72;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=123;tok_ptr:=tok_ptr+1;
while((buffer[loc]>=48)and(buffer[loc]<=57))or((buffer[loc]>=65)and(
buffer[loc]<=70))do begin begin if tok_ptr+2>max_toks then begin
write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=buffer[loc];
tok_ptr:=tok_ptr+1;end;loc:=loc+1;end;begin tok_mem[tok_ptr]:=125;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;end;{:196}{186:}procedure easy_cases;
begin case next_control of 6:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=105;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=110;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;32:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=116;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=111;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;
35,36,37,94,95:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=next_control;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
0,124,131,132,133:;40,91:begin tok_mem[tok_ptr]:=next_control;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=4;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;
41,93:begin tok_mem[tok_ptr]:=next_control;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=6;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
42:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=97;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=115;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=116;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;44:begin tok_mem[tok_ptr]:=44;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=138;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=57;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;
46,48,49,50,51,52,53,54,55,56,57:begin tok_mem[tok_ptr]:=next_control;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;59:begin tok_mem[tok_ptr]:=59;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=9;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;58:begin tok_mem[tok_ptr]:=58;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=14;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;{188:}26:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=73;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
28:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=76;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;29:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=71;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
30:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=83;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;4:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=87;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
31:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=86;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;5:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=82;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
24:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=75;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;{:188}128:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=69;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=123;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=15;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;9:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=66;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
10:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=84;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;12:app_octal;13:app_hex;
135:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=41;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;3:begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=93;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
137:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=44;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;138:begin tok_mem[tok_ptr]:=138;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=48;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
139:begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;app_comment;end;
140:begin tok_mem[tok_ptr]:=142;tok_ptr:=tok_ptr+1;app_comment;end;
141:begin tok_mem[tok_ptr]:=134;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;
begin tok_mem[tok_ptr]:=134;tok_ptr:=tok_ptr+1;app_comment;end;end;
142:begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=9;trans[scrap_ptr]:=0;
end;136:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=74;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;
others:begin tok_mem[tok_ptr]:=next_control;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end end;end;
{:186}{192:}procedure sub_cases(p:name_pointer);
begin case ilk[p]of 0:begin tok_mem[tok_ptr]:=10240+p;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;4:begin tok_mem[tok_ptr]:=20480+p;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=7;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;7:begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=3;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;8:begin tok_mem[tok_ptr]:=131;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;9:begin tok_mem[tok_ptr]:=20480+p;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=8;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;12:begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=7;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
13:begin tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=3;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
16:begin tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
20:begin tok_mem[tok_ptr]:=132;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=125;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;end;end;{:192}procedure Pascal_parse;
label 21,10;var j:0..long_buf_size;p:name_pointer;
begin while next_control<143 do begin{185:}{187:}if(scrap_ptr+4>
max_scraps)or(tok_ptr+6>max_toks)or(text_ptr+4>max_texts)then begin{if
scrap_ptr>max_scr_ptr then max_scr_ptr:=scrap_ptr;
if tok_ptr>max_tok_ptr then max_tok_ptr:=tok_ptr;
if text_ptr>max_txt_ptr then max_txt_ptr:=text_ptr;}
begin write_ln(term_out);
write(term_out,'! Sorry, ','scrap/token/text',' capacity exceeded');
error;history:=3;jump_out;end;end{:187};
21:case next_control of 129,2:{189:}begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;if next_control=2 then begin tok_mem[tok_ptr]:=61;
tok_ptr:=tok_ptr+1;end else begin tok_mem[tok_ptr]:=46;
tok_ptr:=tok_ptr+1;end;tok_mem[tok_ptr]:=123;tok_ptr:=tok_ptr+1;
j:=id_first;
while j<id_loc do begin case buffer[j]of 32,92,35,37,36,94,39,96,123,125
,126,38,95:begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;end;
64:if buffer[j+1]=64 then j:=j+1 else begin if not phase_one then begin
write_ln(term_out);
write(term_out,'! Double @ should be used in strings');error;end;end;
others:end;begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=buffer[j];tok_ptr:=tok_ptr+1;
end;j:=j+1;end;begin tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;end{:189};
130:{191:}begin p:=id_lookup(0);
case ilk[p]of 0,4,7,8,9,12,13,16,20:sub_cases(p);
{193:}5:begin begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=5;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;begin scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=3;trans[scrap_ptr]:=0;end;end;
6:begin begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=21;
trans[scrap_ptr]:=0;end;begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=7;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;end;
10:begin{194:}if(scrap_ptr<scrap_base)or((cat[scrap_ptr]<>10)and(cat[
scrap_ptr]<>9))then begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=10;
trans[scrap_ptr]:=0;end{:194};begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=20;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;end;
11:begin{194:}if(scrap_ptr<scrap_base)or((cat[scrap_ptr]<>10)and(cat[
scrap_ptr]<>9))then begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=10;
trans[scrap_ptr]:=0;end{:194};begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=6;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;end;
14:begin begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=12;
trans[scrap_ptr]:=0;end;begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=7;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;end;
23:begin begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=126;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=7;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;begin tok_mem[tok_ptr]:=20480+p;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=8;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;end;
17:begin begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=20480+p;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=16;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
begin tok_mem[tok_ptr]:=136;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=32;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=3;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;end;
18:begin begin tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=18;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=3;trans[scrap_ptr]:=0;end;
end;19:begin begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=136;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=20480+p;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=5;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=3;trans[scrap_ptr]:=0;end;
end;
21:begin{194:}if(scrap_ptr<scrap_base)or((cat[scrap_ptr]<>10)and(cat[
scrap_ptr]<>9))then begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=10;
trans[scrap_ptr]:=0;end{:194};begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=20480+p;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=6;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;begin scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=13;trans[scrap_ptr]:=0;end;end;
22:begin begin tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=20480+p;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=19;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
begin scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=3;trans[scrap_ptr]:=0;end;
end;{:193}others:begin next_control:=ilk[p]-24;goto 21;end end;
end{:191};134:{190:}begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=104;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=98;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=111;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=120;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=123;
tok_ptr:=tok_ptr+1;
for j:=id_first to id_loc-1 do begin if tok_ptr+2>max_toks then begin
write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=buffer[j];tok_ptr:=tok_ptr+1;
end;begin tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=1;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;end{:190};
others:easy_cases end{:185};next_control:=get_next;
if(next_control=124)or(next_control=123)then goto 10;end;10:end;
{:183}{197:}function Pascal_translate:text_pointer;var p:text_pointer;
save_base:0..max_scraps;begin save_base:=scrap_base;
scrap_base:=scrap_ptr+1;Pascal_parse;
if next_control<>124 then begin if not phase_one then begin write_ln(
term_out);write(term_out,'! Missing "|" after Pascal text');error;end;
end;begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=135;tok_ptr:=tok_ptr+1;end;
app_comment;p:=translate;
{if scrap_ptr>max_scr_ptr then max_scr_ptr:=scrap_ptr;}
scrap_ptr:=scrap_base-1;scrap_base:=save_base;Pascal_translate:=p;end;
{:197}{198:}procedure outer_parse;var bal:eight_bits;p,q:text_pointer;
begin while next_control<143 do if next_control<>123 then Pascal_parse
else begin{199:}if(tok_ptr+7>max_toks)or(text_ptr+3>max_texts)or(
scrap_ptr>=max_scraps)then begin{if scrap_ptr>max_scr_ptr then
max_scr_ptr:=scrap_ptr;if tok_ptr>max_tok_ptr then max_tok_ptr:=tok_ptr;
if text_ptr>max_txt_ptr then max_txt_ptr:=text_ptr;}
begin write_ln(term_out);
write(term_out,'! Sorry, ','token/text/scrap',' capacity exceeded');
error;history:=3;jump_out;end;end{:199};tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=67;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=123;tok_ptr:=tok_ptr+1;bal:=copy_comment(1);
next_control:=124;while bal>0 do begin p:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;q:=Pascal_translate;
tok_mem[tok_ptr]:=40960+p;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=51200+q;
tok_ptr:=tok_ptr+1;
if next_control=124 then bal:=copy_comment(bal)else bal:=0;end;
tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;app_comment;end;end;
{:198}{204:}procedure push_level(p:text_pointer);
begin if stack_ptr=stack_size then begin write_ln(term_out);
write(term_out,'! Sorry, ','stack',' capacity exceeded');error;
history:=3;jump_out;
end else begin if stack_ptr>0 then stack[stack_ptr]:=cur_state;
stack_ptr:=stack_ptr+1;
{if stack_ptr>max_stack_ptr then max_stack_ptr:=stack_ptr;}
cur_state.tok_field:=tok_start[p];cur_state.end_field:=tok_start[p+1];
end;end;{:204}{206:}function get_output:eight_bits;label 20;
var a:sixteen_bits;
begin 20:while cur_state.tok_field=cur_state.end_field do begin
stack_ptr:=stack_ptr-1;cur_state:=stack[stack_ptr];end;
a:=tok_mem[cur_state.tok_field];
cur_state.tok_field:=cur_state.tok_field+1;
if a>=256 then begin cur_name:=a mod 10240;case a div 10240 of 2:a:=129;
3:a:=128;4:begin push_level(cur_name);goto 20;end;
5:begin push_level(cur_name);cur_state.mode_field:=0;goto 20;end;
others:a:=130 end;end;{if trouble_shooting then debug_help;}
get_output:=a;end;{:206}{207:}procedure make_output;forward;
procedure output_Pascal;
var save_tok_ptr,save_text_ptr,save_next_control:sixteen_bits;
p:text_pointer;begin save_tok_ptr:=tok_ptr;save_text_ptr:=text_ptr;
save_next_control:=next_control;next_control:=124;p:=Pascal_translate;
tok_mem[tok_ptr]:=p+51200;tok_ptr:=tok_ptr+1;make_output;
{if text_ptr>max_txt_ptr then max_txt_ptr:=text_ptr;
if tok_ptr>max_tok_ptr then max_tok_ptr:=tok_ptr;}
text_ptr:=save_text_ptr;tok_ptr:=save_tok_ptr;
next_control:=save_next_control;end;{:207}{208:}procedure make_output;
label 21,10,31;var a:eight_bits;b:eight_bits;k,k_limit:0..max_bytes;
w:0..1;j:0..long_buf_size;string_delimiter:ASCII_code;
save_loc,save_limit:0..long_buf_size;cur_mod_name:name_pointer;
save_mode:mode;begin tok_mem[tok_ptr]:=143;tok_ptr:=tok_ptr+1;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;
push_level(text_ptr-1);while true do begin a:=get_output;
21:case a of 143:goto 10;
130,129:{209:}begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;end;
if a=130 then if byte_start[cur_name+2]-byte_start[cur_name]=1 then
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=124;
end else begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;
end else begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=38;end;
if byte_start[cur_name+2]-byte_start[cur_name]=1 then begin if out_ptr=
line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=byte_mem[cur_name mod 2,byte_start[cur_name]];
end else out_name(cur_name);end{:209};
128:{213:}begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=88;end;cur_xref:=xref[cur_name];
if xmem[cur_xref].num_field>=10240 then begin out_mod(xmem[cur_xref].
num_field-10240);
if phase_three then begin cur_xref:=xmem[cur_xref].xlink_field;
while xmem[cur_xref].num_field>=10240 do begin begin if out_ptr=
line_length then break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=44;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=32;end;out_mod(xmem[cur_xref].num_field-10240);
cur_xref:=xmem[cur_xref].xlink_field;end;end;
end else begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=48;end;begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=58;end;
{214:}k:=byte_start[cur_name];w:=cur_name mod 2;
k_limit:=byte_start[cur_name+2];cur_mod_name:=cur_name;
while k<k_limit do begin b:=byte_mem[w,k];k:=k+1;
if b=64 then{215:}begin if byte_mem[w,k]<>64 then begin begin write_ln(
term_out);write(term_out,'! Illegal control code in section name:');end;
begin write_ln(term_out);write(term_out,'<');end;print_id(cur_mod_name);
write(term_out,'> ');history:=2;end;k:=k+1;end{:215};
if b<>124 then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=b;end else begin{216:}j:=limit+1;
buffer[j]:=124;string_delimiter:=0;
while true do begin if k>=k_limit then begin begin write_ln(term_out);
write(term_out,'! Pascal text in section name didn''t end:');end;
begin write_ln(term_out);write(term_out,'<');end;print_id(cur_mod_name);
write(term_out,'> ');history:=2;goto 31;end;b:=byte_mem[w,k];k:=k+1;
if b=64 then{217:}begin if j>long_buf_size-4 then begin write_ln(
term_out);write(term_out,'! Sorry, ','buffer',' capacity exceeded');
error;history:=3;jump_out;end;buffer[j+1]:=64;
buffer[j+2]:=byte_mem[w,k];j:=j+2;k:=k+1;
end{:217}else begin if(b=34)or(b=39)then if string_delimiter=0 then
string_delimiter:=b else if string_delimiter=b then string_delimiter:=0;
if(b<>124)or(string_delimiter<>0)then begin if j>long_buf_size-3 then
begin write_ln(term_out);
write(term_out,'! Sorry, ','buffer',' capacity exceeded');error;
history:=3;jump_out;end;j:=j+1;buffer[j]:=b;end else goto 31;end;end;
31:{:216};save_loc:=loc;save_limit:=limit;loc:=limit+2;limit:=j+1;
buffer[limit]:=124;output_Pascal;loc:=save_loc;limit:=save_limit;end;
end{:214};begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=88;end;end{:213};
131,133,132:{210:}begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=109;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=97;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=116;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=104;end;
if a=131 then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=98;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=105;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=110;
end else if a=132 then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=114;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=101;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=108;
end else begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=111;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=112;end;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=123;end;end{:210};135:begin repeat a:=get_output;
until(a<139)or(a>142);goto 21;end;134:begin repeat a:=get_output;
until((a<139)and(a<>32))or(a>142);goto 21;end;
136,137,138,139,140,141,142:{211:}if a<140 then begin if cur_state.
mode_field=1 then begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=a-87;end;
if a=138 then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=get_output;
end end else if a=138 then b:=get_output end else{212:}begin b:=a;
save_mode:=cur_state.mode_field;while true do begin a:=get_output;
if(a=135)or(a=134)then goto 21;
if((a<>32)and(a<140))or(a>142)then begin if save_mode=1 then begin if
out_ptr>3 then if(out_buf[out_ptr]=80)and(out_buf[out_ptr-1]=92)and(
out_buf[out_ptr-2]=89)and(out_buf[out_ptr-3]=92)then goto 21;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=b-87;end;
if a<>143 then finish_line;
end else if(a<>143)and(cur_state.mode_field=0)then begin if out_ptr=
line_length then break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=32;end;
goto 21;end;if a>b then b:=a;end;end{:212}{:211};
others:begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=a;end end;end;10:end;
{:208}{226:}procedure finish_Pascal;var p:text_pointer;
begin begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=80;end;
begin if tok_ptr+2>max_toks then begin write_ln(term_out);
write(term_out,'! Sorry, ','token',' capacity exceeded');error;
history:=3;jump_out;end;tok_mem[tok_ptr]:=141;tok_ptr:=tok_ptr+1;end;
app_comment;p:=translate;tok_mem[tok_ptr]:=p+40960;tok_ptr:=tok_ptr+1;
make_output;
if out_ptr>1 then if out_buf[out_ptr-1]=92 then if out_buf[out_ptr]=54
then out_ptr:=out_ptr-2 else if out_buf[out_ptr]=55 then out_buf[out_ptr
]:=89;begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=112;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=97;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=114;end;finish_line;
{if text_ptr>max_txt_ptr then max_txt_ptr:=text_ptr;
if tok_ptr>max_tok_ptr then max_tok_ptr:=tok_ptr;
if scrap_ptr>max_scr_ptr then max_scr_ptr:=scrap_ptr;}tok_ptr:=1;
text_ptr:=1;scrap_ptr:=0;end;
{:226}{236:}procedure footnote(flag:sixteen_bits);label 30,10;
var q:xref_number;begin if xmem[cur_xref].num_field<=flag then goto 10;
finish_line;begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;end;
if flag=0 then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=85;
end else begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=65;end;{237:}q:=cur_xref;
if xmem[xmem[q].xlink_field].num_field>flag then begin if out_ptr=
line_length then break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=115;end;
while true do begin out_mod(xmem[cur_xref].num_field-flag);
cur_xref:=xmem[cur_xref].xlink_field;
if xmem[cur_xref].num_field<=flag then goto 30;
if xmem[xmem[cur_xref].xlink_field].num_field>flag then begin if out_ptr
=line_length then break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=44;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=32;
end else begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=69;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=84;end;
if cur_xref<>xmem[q].xlink_field then begin if out_ptr=line_length then
break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=115;end;end;end;
30:{:237};begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=46;end;10:end;
{:236}{249:}procedure unbucket(d:eight_bits);var c:ASCII_code;
begin for c:=229 downto 0 do if bucket[collate[c]]>0 then begin if
scrap_ptr>max_scraps then begin write_ln(term_out);
write(term_out,'! Sorry, ','sorting',' capacity exceeded');error;
history:=3;jump_out;end;scrap_ptr:=scrap_ptr+1;
{if scrap_ptr>max_sort_ptr then max_sort_ptr:=scrap_ptr;}
if c=0 then cat[scrap_ptr]:=255 else cat[scrap_ptr]:=d;
trans[scrap_ptr]:=bucket[collate[c]];bucket[collate[c]]:=0;end;end;
{:249}{256:}procedure mod_print(p:name_pointer);
begin if p>0 then begin mod_print(link[p]);
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=58;end;tok_ptr:=1;text_ptr:=1;
scrap_ptr:=0;stack_ptr:=0;cur_state.mode_field:=1;
tok_mem[tok_ptr]:=p+30720;tok_ptr:=tok_ptr+1;make_output;footnote(0);
finish_line;mod_print(ilk[p]);end;end;{:256}{260:}{procedure debug_help;
label 888,10;var k:integer;begin debug_skipped:=debug_skipped+1;
if debug_skipped<debug_cycle then goto 10;debug_skipped:=0;
while true do begin begin write_ln(term_out);write(term_out,'#');end;
break(term_out);read(term_in,ddt);
if ddt<0 then goto 10 else if ddt=0 then begin goto 888;
888:ddt:=0;
end else begin read(term_in,dd);case ddt of 1:print_id(dd);
2:print_text(dd);3:for k:=1 to dd do write(term_out,xchr[buffer[k]]);
4:for k:=1 to dd do write(term_out,xchr[mod_text[k]]);
5:for k:=1 to out_ptr do write(term_out,xchr[out_buf[k]]);
6:for k:=1 to dd do begin print_cat(cat[k]);write(term_out,' ');end;
others:write(term_out,'?')end;end;end;10:end;}
{:260}{261:}procedure Phase_I;begin{109:}phase_one:=true;
phase_three:=false;reset_input;module_count:=0;skip_limbo;
change_exists:=false;
while not input_has_ended do{110:}begin module_count:=module_count+1;
if module_count=max_modules then begin write_ln(term_out);
write(term_out,'! Sorry, ','section number',' capacity exceeded');error;
history:=3;jump_out;end;changed_module[module_count]:=changing;
if buffer[loc-1]=42 then begin write(term_out,'*',module_count:1);
break(term_out);end;{113:}repeat next_control:=skip_TeX;
case next_control of 126:xref_switch:=10240;125:xref_switch:=0;
124:Pascal_xref;131,132,133,146:begin loc:=loc-2;next_control:=get_next;
if next_control<>146 then new_xref(id_lookup(next_control-130));end;
others:end;until next_control>=143{:113};
{115:}while next_control<=144 do begin xref_switch:=10240;
if next_control=144 then next_control:=get_next else{116:}begin
next_control:=get_next;if next_control=130 then begin lhs:=id_lookup(0);
ilk[lhs]:=0;new_xref(lhs);next_control:=get_next;
if next_control=30 then begin next_control:=get_next;
if next_control=130 then begin rhs:=id_lookup(0);ilk[lhs]:=ilk[rhs];
ilk[rhs]:=0;new_xref(rhs);ilk[rhs]:=ilk[lhs];next_control:=get_next;end;
end;end;end{:116};outer_xref;end{:115};
{117:}if next_control<=146 then begin if next_control=145 then
mod_xref_switch:=0 else mod_xref_switch:=10240;
repeat if next_control=146 then new_mod_xref(cur_module);
next_control:=get_next;outer_xref;until next_control>146;end{:117};
if changed_module[module_count]then change_exists:=true;end{:110};
changed_module[module_count]:=change_exists;phase_one:=false;
{120:}mod_check(ilk[0]){:120};{:109};end;procedure Phase_II;
begin{218:}reset_input;begin write_ln(term_out);
write(term_out,'Writing the output file...');end;module_count:=0;
copy_limbo;finish_line;flush_buffer(0,false,false);
while not input_has_ended do{220:}begin module_count:=module_count+1;
{221:}begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;end;
if buffer[loc-1]<>42 then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=77;
end else begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=78;end;
write(term_out,'*',module_count:1);break(term_out);end;
out_mod(module_count);begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=46;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=32;end{:221};save_line:=out_line;save_place:=out_ptr;
{222:}repeat next_control:=copy_TeX;
case next_control of 124:begin stack_ptr:=0;cur_state.mode_field:=1;
output_Pascal;end;64:begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=64;end;
12:{223:}begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=79;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=123;end;
while(buffer[loc]>=48)and(buffer[loc]<=55)do begin begin if out_ptr=
line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=buffer[loc];end;loc:=loc+1;end;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=125;end;end{:223};
13:{224:}begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=72;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=123;end;
while((buffer[loc]>=48)and(buffer[loc]<=57))or((buffer[loc]>=65)and(
buffer[loc]<=70))do begin begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=buffer[loc];end;loc:=loc+1;end;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=125;end;end{:224};
134,131,132,133,146:begin loc:=loc-2;next_control:=get_next;
if next_control=134 then begin if not phase_one then begin write_ln(
term_out);write(term_out,'! TeX string should be in Pascal text only');
error;end;end;end;
9,10,135,137,138,139,140,141,136,142:begin if not phase_one then begin
write_ln(term_out);write(term_out,'! You can''t do that in TeX text');
error;end;end;others:end;until next_control>=143{:222};
{225:}if next_control<=144 then begin if(save_line<>out_line)or(
save_place<>out_ptr)then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=89;end;save_line:=out_line;save_place:=out_ptr;end;
while next_control<=144 do begin stack_ptr:=0;cur_state.mode_field:=1;
if next_control=144 then{227:}begin begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=68;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=3;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
next_control:=get_next;
if next_control<>130 then begin if not phase_one then begin write_ln(
term_out);write(term_out,'! Improper macro definition');error;end;
end else begin tok_mem[tok_ptr]:=10240+id_lookup(0);tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
next_control:=get_next;
end{:227}else{228:}begin begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;
tok_mem[tok_ptr]:=70;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=3;trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;next_control:=get_next;
if next_control=130 then begin begin tok_mem[tok_ptr]:=10240+id_lookup(0
);tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;next_control:=get_next;
if next_control=30 then begin begin tok_mem[tok_ptr]:=92;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=83;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
next_control:=get_next;
if next_control=130 then begin begin tok_mem[tok_ptr]:=10240+id_lookup(0
);tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;begin scrap_ptr:=scrap_ptr+1;
cat[scrap_ptr]:=9;trans[scrap_ptr]:=0;end;next_control:=get_next;end;
end;end;
if scrap_ptr<>5 then begin if not phase_one then begin write_ln(term_out
);write(term_out,'! Improper format definition');error;end;end;
end{:228};outer_parse;finish_Pascal;end{:225};{230:}this_module:=0;
if next_control<=146 then begin if(save_line<>out_line)or(save_place<>
out_ptr)then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=89;end;stack_ptr:=0;cur_state.mode_field:=1;
if next_control=145 then next_control:=get_next else begin this_module:=
cur_module;{231:}repeat next_control:=get_next;until next_control<>43;
if(next_control<>61)and(next_control<>30)then begin if not phase_one
then begin write_ln(term_out);
write(term_out,'! You need an = sign after the section name');error;end;
end else next_control:=get_next;
if out_ptr>1 then if(out_buf[out_ptr]=89)and(out_buf[out_ptr-1]=92)then
begin tok_mem[tok_ptr]:=139;tok_ptr:=tok_ptr+1;end;
begin tok_mem[tok_ptr]:=30720+this_module;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=22;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;
cur_xref:=xref[this_module];
if xmem[cur_xref].num_field<>module_count+10240 then begin begin tok_mem
[tok_ptr]:=132;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=43;
tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=125;tok_ptr:=tok_ptr+1;
scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;trans[scrap_ptr]:=text_ptr;
text_ptr:=text_ptr+1;tok_start[text_ptr]:=tok_ptr;end;this_module:=0;
end;begin tok_mem[tok_ptr]:=92;tok_ptr:=tok_ptr+1;tok_mem[tok_ptr]:=83;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=2;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;begin tok_mem[tok_ptr]:=141;
tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=9;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;{:231};end;
while next_control<=146 do begin outer_parse;
{232:}if next_control<146 then begin begin if not phase_one then begin
write_ln(term_out);
write(term_out,'! You can''t do that in Pascal text');error;end;end;
next_control:=get_next;
end else if next_control=146 then begin begin tok_mem[tok_ptr]:=30720+
cur_module;tok_ptr:=tok_ptr+1;scrap_ptr:=scrap_ptr+1;cat[scrap_ptr]:=22;
trans[scrap_ptr]:=text_ptr;text_ptr:=text_ptr+1;
tok_start[text_ptr]:=tok_ptr;end;next_control:=get_next;end{:232};end;
finish_Pascal;end{:230};
{233:}if this_module>0 then begin{235:}first_xref:=xref[this_module];
this_xref:=xmem[first_xref].xlink_field;
if xmem[this_xref].num_field>10240 then begin mid_xref:=this_xref;
cur_xref:=0;repeat next_xref:=xmem[this_xref].xlink_field;
xmem[this_xref].xlink_field:=cur_xref;cur_xref:=this_xref;
this_xref:=next_xref;until xmem[this_xref].num_field<=10240;
xmem[first_xref].xlink_field:=cur_xref;end else mid_xref:=0;cur_xref:=0;
while this_xref<>0 do begin next_xref:=xmem[this_xref].xlink_field;
xmem[this_xref].xlink_field:=cur_xref;cur_xref:=this_xref;
this_xref:=next_xref;end;
if mid_xref>0 then xmem[mid_xref].xlink_field:=cur_xref else xmem[
first_xref].xlink_field:=cur_xref;
cur_xref:=xmem[first_xref].xlink_field{:235};footnote(10240);
footnote(0);end{:233};{238:}begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=102;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=105;end;finish_line;
flush_buffer(0,false,false);{:238};end{:220}{:218};end;begin initialize;
write_ln(term_out,'This is WEAVE, Version 4.4');{64:}id_loc:=10;
id_first:=7;buffer[7]:=97;buffer[8]:=110;buffer[9]:=100;
cur_name:=id_lookup(28);id_first:=5;buffer[5]:=97;buffer[6]:=114;
buffer[7]:=114;buffer[8]:=97;buffer[9]:=121;cur_name:=id_lookup(4);
id_first:=5;buffer[5]:=98;buffer[6]:=101;buffer[7]:=103;buffer[8]:=105;
buffer[9]:=110;cur_name:=id_lookup(5);id_first:=6;buffer[6]:=99;
buffer[7]:=97;buffer[8]:=115;buffer[9]:=101;cur_name:=id_lookup(6);
id_first:=5;buffer[5]:=99;buffer[6]:=111;buffer[7]:=110;buffer[8]:=115;
buffer[9]:=116;cur_name:=id_lookup(7);id_first:=7;buffer[7]:=100;
buffer[8]:=105;buffer[9]:=118;cur_name:=id_lookup(8);id_first:=8;
buffer[8]:=100;buffer[9]:=111;cur_name:=id_lookup(9);id_first:=4;
buffer[4]:=100;buffer[5]:=111;buffer[6]:=119;buffer[7]:=110;
buffer[8]:=116;buffer[9]:=111;cur_name:=id_lookup(20);id_first:=6;
buffer[6]:=101;buffer[7]:=108;buffer[8]:=115;buffer[9]:=101;
cur_name:=id_lookup(10);id_first:=7;buffer[7]:=101;buffer[8]:=110;
buffer[9]:=100;cur_name:=id_lookup(11);id_first:=6;buffer[6]:=102;
buffer[7]:=105;buffer[8]:=108;buffer[9]:=101;cur_name:=id_lookup(4);
id_first:=7;buffer[7]:=102;buffer[8]:=111;buffer[9]:=114;
cur_name:=id_lookup(12);id_first:=2;buffer[2]:=102;buffer[3]:=117;
buffer[4]:=110;buffer[5]:=99;buffer[6]:=116;buffer[7]:=105;
buffer[8]:=111;buffer[9]:=110;cur_name:=id_lookup(17);id_first:=6;
buffer[6]:=103;buffer[7]:=111;buffer[8]:=116;buffer[9]:=111;
cur_name:=id_lookup(13);id_first:=8;buffer[8]:=105;buffer[9]:=102;
cur_name:=id_lookup(14);id_first:=8;buffer[8]:=105;buffer[9]:=110;
cur_name:=id_lookup(30);id_first:=5;buffer[5]:=108;buffer[6]:=97;
buffer[7]:=98;buffer[8]:=101;buffer[9]:=108;cur_name:=id_lookup(7);
id_first:=7;buffer[7]:=109;buffer[8]:=111;buffer[9]:=100;
cur_name:=id_lookup(8);id_first:=7;buffer[7]:=110;buffer[8]:=105;
buffer[9]:=108;cur_name:=id_lookup(16);id_first:=7;buffer[7]:=110;
buffer[8]:=111;buffer[9]:=116;cur_name:=id_lookup(29);id_first:=8;
buffer[8]:=111;buffer[9]:=102;cur_name:=id_lookup(9);id_first:=8;
buffer[8]:=111;buffer[9]:=114;cur_name:=id_lookup(55);id_first:=4;
buffer[4]:=112;buffer[5]:=97;buffer[6]:=99;buffer[7]:=107;
buffer[8]:=101;buffer[9]:=100;cur_name:=id_lookup(13);id_first:=1;
buffer[1]:=112;buffer[2]:=114;buffer[3]:=111;buffer[4]:=99;
buffer[5]:=101;buffer[6]:=100;buffer[7]:=117;buffer[8]:=114;
buffer[9]:=101;cur_name:=id_lookup(17);id_first:=3;buffer[3]:=112;
buffer[4]:=114;buffer[5]:=111;buffer[6]:=103;buffer[7]:=114;
buffer[8]:=97;buffer[9]:=109;cur_name:=id_lookup(17);id_first:=4;
buffer[4]:=114;buffer[5]:=101;buffer[6]:=99;buffer[7]:=111;
buffer[8]:=114;buffer[9]:=100;cur_name:=id_lookup(18);id_first:=4;
buffer[4]:=114;buffer[5]:=101;buffer[6]:=112;buffer[7]:=101;
buffer[8]:=97;buffer[9]:=116;cur_name:=id_lookup(19);id_first:=7;
buffer[7]:=115;buffer[8]:=101;buffer[9]:=116;cur_name:=id_lookup(4);
id_first:=6;buffer[6]:=116;buffer[7]:=104;buffer[8]:=101;buffer[9]:=110;
cur_name:=id_lookup(9);id_first:=8;buffer[8]:=116;buffer[9]:=111;
cur_name:=id_lookup(20);id_first:=6;buffer[6]:=116;buffer[7]:=121;
buffer[8]:=112;buffer[9]:=101;cur_name:=id_lookup(7);id_first:=5;
buffer[5]:=117;buffer[6]:=110;buffer[7]:=116;buffer[8]:=105;
buffer[9]:=108;cur_name:=id_lookup(21);id_first:=7;buffer[7]:=118;
buffer[8]:=97;buffer[9]:=114;cur_name:=id_lookup(22);id_first:=5;
buffer[5]:=119;buffer[6]:=104;buffer[7]:=105;buffer[8]:=108;
buffer[9]:=101;cur_name:=id_lookup(12);id_first:=6;buffer[6]:=119;
buffer[7]:=105;buffer[8]:=116;buffer[9]:=104;cur_name:=id_lookup(12);
id_first:=3;buffer[3]:=120;buffer[4]:=99;buffer[5]:=108;buffer[6]:=97;
buffer[7]:=117;buffer[8]:=115;buffer[9]:=101;cur_name:=id_lookup(23);
{:64};Phase_I;Phase_II;{239:}phase_three:=true;begin write_ln(term_out);
write(term_out,'Writing the index...');end;
if change_exists then begin finish_line;{241:}begin k_module:=1;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=99;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=104;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=32;end;
while k_module<module_count do begin if changed_module[k_module]then
begin out_mod(k_module);begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=44;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=32;end;end;k_module:=k_module+1;end;out_mod(k_module);
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=46;end;end{:241};end;finish_line;
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=105;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=110;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=120;end;finish_line;
{243:}for c:=0 to 255 do bucket[c]:=0;
for h:=0 to hash_size-1 do begin next_name:=hash[h];
while next_name<>0 do begin cur_name:=next_name;
next_name:=link[cur_name];
if xref[cur_name]<>0 then begin c:=byte_mem[cur_name mod 2,byte_start[
cur_name]];if(c<=90)and(c>=65)then c:=c+32;blink[cur_name]:=bucket[c];
bucket[c]:=cur_name;end;end;end{:243};{250:}scrap_ptr:=0;unbucket(1);
while scrap_ptr>0 do begin cur_depth:=cat[scrap_ptr];
if(blink[trans[scrap_ptr]]=0)or(cur_depth=255)then{252:}begin cur_name:=
trans[scrap_ptr];{if trouble_shooting then debug_help;}
repeat begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=58;end;
{253:}case ilk[cur_name]of 0:if byte_start[cur_name+2]-byte_start[
cur_name]=1 then begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=124;
end else begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;end;1:;
2:begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=57;end;
3:begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=46;end;
others:begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=38;end end;
out_name(cur_name){:253};{254:}{255:}this_xref:=xref[cur_name];
cur_xref:=0;repeat next_xref:=xmem[this_xref].xlink_field;
xmem[this_xref].xlink_field:=cur_xref;cur_xref:=this_xref;
this_xref:=next_xref;until this_xref=0{:255};
repeat begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=44;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=32;end;
cur_val:=xmem[cur_xref].num_field;
if cur_val<10240 then out_mod(cur_val)else begin begin if out_ptr=
line_length then break_out;out_ptr:=out_ptr+1;out_buf[out_ptr]:=92;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=91;end;out_mod(cur_val-10240);
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=93;end;end;cur_xref:=xmem[cur_xref].xlink_field;
until cur_xref=0;begin if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=46;end;finish_line{:254};
cur_name:=blink[cur_name];until cur_name=0;scrap_ptr:=scrap_ptr-1;
end{:252}else{251:}begin next_name:=trans[scrap_ptr];
repeat cur_name:=next_name;next_name:=blink[cur_name];
cur_byte:=byte_start[cur_name]+cur_depth;cur_bank:=cur_name mod 2;
if cur_byte=byte_start[cur_name+2]then c:=0 else begin c:=byte_mem[
cur_bank,cur_byte];if(c<=90)and(c>=65)then c:=c+32;end;
blink[cur_name]:=bucket[c];bucket[c]:=cur_name;until next_name=0;
scrap_ptr:=scrap_ptr-1;unbucket(cur_depth+1);end{:251};end{:250};
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=102;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=105;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=110;end;finish_line;
{257:}mod_print(ilk[0]){:257};
begin if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=92;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=99;
if out_ptr=line_length then break_out;out_ptr:=out_ptr+1;
out_buf[out_ptr]:=111;if out_ptr=line_length then break_out;
out_ptr:=out_ptr+1;out_buf[out_ptr]:=110;end;finish_line;
write(term_out,'Done.');{:239};
{85:}if change_limit<>0 then begin for ii:=0 to change_limit do buffer[
ii]:=change_buffer[ii];limit:=change_limit;changing:=true;
line:=other_line;loc:=change_limit;
begin if not phase_one then begin write_ln(term_out);
write(term_out,'! Change file entry did not match');error;end;end;
end{:85};9999:{[262:]begin write_ln(term_out);
write(term_out,'Memory usage statistics: ',name_ptr:1,' names, ',
xref_ptr:1,' cross references, ',byte_ptr[0]:1);end;
for cur_bank:=1 to 1 do write(term_out,'+',byte_ptr[cur_bank]:1);
write(term_out,' bytes;');begin write_ln(term_out);
write(term_out,'parsing required ',max_scr_ptr:1,' scraps, ',max_txt_ptr
:1,' texts, ',max_tok_ptr:1,' tokens, ',max_stack_ptr:1,' levels;');end;
begin write_ln(term_out);
write(term_out,'sorting required ',max_sort_ptr:1,' levels.');end[:262];
}{263:}case history of 0:begin write_ln(term_out);
write(term_out,'(No errors were found.)');end;
1:begin write_ln(term_out);
write(term_out,'(Did you see the warning message above?)');end;
2:begin write_ln(term_out);
write(term_out,'(Pardon me, but I think I spotted something wrong.)');
end;3:begin write_ln(term_out);
write(term_out,'(That was a fatal error, my friend.)');end;end{:263};
end.{:261}
